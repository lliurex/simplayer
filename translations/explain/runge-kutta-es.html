<!DOCTYPE html>
<html lang="es">
<head>
<title lang="es">Algoritmo de Runge-Kutta</title>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../common/stylesheet1.css">

<script type="text/javascript" async
  src="../../mathjax/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
</head>
<body>

<h1 lang="es">Algoritmo de Runge-Kutta</h1>

<div id="header_nav">
<a class="nav_link"
   href="numerical-solution-es.html">anterior</a>
<a class="nav_link"
   href="math-refresh-es.html">siguiente</a>
</div>
<ul id="header_bar">
</ul>

<p class="introduction">El algoritmo de Runge-Kutta es <em>la</em> fórmula mágica detrás
  la mayoría de las simulaciones de física
  que se muestra en este sitio web. El algoritmo de Runge-Kutta nos permite resolver una ecuación diferencial
  numéricamente (es decir, aproximadamente); se sabe que es muy preciso y se comporta bien
  para una amplia gama de problemas. </p>


  <p>Considere el problema de una sola variable</p>

<p class="html-math display-equation">
<i>x</i>' = <i>f</i> (<i>t</i>, <i>x</i>)
</p>

<p>con condición inicial <span class="html-math inline-math">
<i>x</i>(0) = <i>x</i><sub>0</sub>
</span>. Supongamos que <span class="html-math inline-math">
<i>x<sub>n</sub></i>
</span> es el valor de
la variable en el momento <span class="html-math inline-math">
<i>t<sub>n</sub></i>
</span>. La fórmula de Runge-Kutta toma <span class="html-math inline-math">
<i>x<sub>n</sub></i>
</span> y
<span class="html-math inline-math">
<i>t<sub>n</sub></i>
</span> y calcula una aproximación para <span class="html-math inline-math">
<i>x</i><sub><i>n</i>+1</sub>
</span> en un breve
tiempo después, <span class="html-math inline-math">
<i>t<sub>n</sub></i>+<i>h</i>
</span>. Utiliza un promedio ponderado de valores aproximados de
<span class="html-math inline-math">
<i>f</i> (<i>t</i>, <i>x</i>)
</span> varias veces dentro del intervalo <span class="html-math inline-math">
(<i>t<sub>n</sub></i>, <i>t<sub>n</sub></i>+<i>h</i>)
</span>. La fórmula está dada por</p>

<p class="html-math display-equation">
<i>x</i><sub><i>n</i>+1</sub> = <i>x<sub>n</sub></i> + <sup><i>h</i></sup>&frasl;<sub>6</sub> (<i>a</i> + 2 <i>b</i> + 2 <i>c</i> + <i>d</i>)
</p>

<p>donde</p>

<p class="html-math display-equation">
<i>a</i> = <i>f</i> (<i>t<sub>n</sub></i>, <i>x<sub>n</sub></i>)<br>

<i>b</i> = <i>f</i> (<i>t<sub>n</sub></i> + <sup><i>h</i></sup>&frasl;<sub>2</sub>, <i>x<sub>n</sub></i> + <sup><i>h</i></sup>&frasl;<sub>2</sub> <i>a</i>)<br>

<i>c</i> = <i>f</i> (<i>t<sub>n</sub></i> + <sup><i>h</i></sup>&frasl;<sub>2</sub>, <i>x<sub>n</sub></i> + <sup><i>h</i></sup>&frasl;<sub>2</sub> <i>b</i>)<br>

<i>d</i> = <i>f</i> (<i>t<sub>n</sub></i> + <i>h</i>, <i>x<sub>n</sub></i> + <i>h</i> <i>c</i>)
</p>

<p>Para ejecutar la simulación, comenzamos con <span class="html-math inline-math">
<i>x</i><sub>0</sub>
</span> y buscamos <span class="html-math inline-math">
<i>x</i><sub>1</sub>
</span> usando el
fórmula anterior. Luego conectamos <span class="html-math inline-math">
<i>x</i><sub>1</sub>
</span> para buscar <span class="html-math inline-math">
<i>x</i><sub>2</sub>
</span> y así sucesivamente.</p>


<h2>Algoritmo de Runge-Kutta multivariable</h2>

<p>Con múltiples variables, el algoritmo de Runge-Kutta se parece a las ecuaciones anteriores, excepto que las variables se convierten en vectores.</p>


<p><p>El Algoritmo de Runge-Kutta es bastante simple, pero para describirlo con precisión necesitamos
  desarrollar alguna notación. Supongamos que hay <span class="html-math inline-math">
<i>m</i>
</span> variables
<span class="html-math inline-math">
<i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, ..., <i>x<sub>m</sub></i>
</span> cada una de las cuales varía con el tiempo. por ejemplo, en la
<a href="../SingleSpringApp/SingleSpringApp-es.html">simulación de muelle simple</a>, <span class="html-math inline-math">
<i>x<sub>1</sub></i>
</span> es posición, <span class="html-math inline-math">
<i>x<sub>2</sub></i>
</span> es velocidad. Supongamos además que
hay <span class="html-math inline-math">
<i>m</i>
</span> ecuaciones diferenciales para estas <span class="html-math inline-math">
<i>m</i>
</span> variables</p>

<p class="html-math display-equation">
<i>x<sub>1</sub></i>' = <i>f<sub>1</sub></i>(<i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, ..., <i>x<sub>m</sub></i>)<br>
<i>x<sub>2</sub></i>' = <i>f<sub>2</sub></i>(<i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, ..., <i>x<sub>m</sub></i>)<br>
...<br>
<i>x<sub>m</sub></i>' = <i>f<sub>m</sub></i>(<i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, ..., <i>x<sub>m</sub></i>)
</p>

<p>Observe que no hay derivadas en el lado derecho de ninguna de esas ecuaciones,
  y solo hay primeras derivadas en el lado izquierdo. Estas ecuaciones pueden ser
  resumidas en forma vectorial como
</p>

<p class="html-math display-equation">
<span class="vector">x</span>' = <span class="vector">f</span> (<span class="vector">x</span>)
</p>

<p>donde <span class="html-math inline-math">
<span class="vector">x</span> = (<i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, ..., <i>x<sub>m</sub></i>)
</span> y permitimos algún ligero "vector de funciones" donde
<span class="html-math inline-math">
<span class="vector">f</span> = (<i>f<sub>1</sub></i>, <i>f<sub>2</sub></i>, ..., <i>f<sub>m</sub></i>)
</span>. A continuación etiquetamos nuestros estados de tiempo
<span class="html-math inline-math">
<span class="vector">x</span><sub><i>n</i></sub>, <span class="vector">x</span><sub><i>n</i>+1</sub>
</span> que están separados por un intervalo de tiempo de longitud
<span class="html-math inline-math">
<i>h</i>
</span>. Es decir, <span class="html-math inline-math">
<span class="vector">x</span><sub><i>n</i></sub>
</span> es el valor de <span class="html-math inline-math">
<i>m</i>
</span> las variables en el tiempo<span class="html-math inline-math">
<i>t</i><sub><i>n</i></sub>
</span>. Y <span class="html-math inline-math">
<i>x</i><sub>1,<i>n</i></sub>
</span> es el valor de la primera variable
<span class="html-math inline-math">
<i>x<sub>1</sub></i>
</span> en el momento <span class="html-math inline-math">
<i>t</i><sub><i>n</i></sub>
</span>.
</p>


<p class="html-math display-equation">
<span class="vector">x</span><sub><i>n</i></sub> = (<i>x</i><sub>1,<i>n</i></sub>, <i>x</i><sub>2,<i>n</i></sub>, ..., <i>x</i><sub><i>m</i>,<i>n</i></sub>)<br>
<span class="vector">x</span><sub><i>n</i>+1</sub> = (<i>x</i><sub>1,<i>n</i>+1</sub>, <i>x</i><sub>2,<i>n</i>+1</sub>, ..., <i>x</i><sub><i>m</i>,<i>n</i>+1</sub>)
</p>

<p>Supongamos que tenemos el estado de la simulación en el momento <span class="html-math inline-math">
<i>t</i><sub><i>n</i></sub>
</span> como
<span class="html-math inline-math">
<span class="vector">x</span><sub><i>n</i></sub>
</span>. Para calcular el estado en el periodo de tiempo <span class="html-math inline-math">
<i>h</i>
</span> y más tarde poner el resultado en
<span class="html-math inline-math">
<span class="vector">x</span><sub><i>n</i>+1</sub>
</span>, el algoritmo de Runge-Kutta hace lo siguiente:
</p>

<p class="html-math display-equation">
<span class="vector">a</span><sub><i>n</i></sub> = <span class="vector">f</span>(<span class="vector">x</span><sub><i>n</i></sub>) <br>
<span class="vector">b</span><sub><i>n</i></sub> = <span class="vector">f</span>(<span class="vector">x</span><sub><i>n</i></sub> + <sup><i>h</i></sup>&frasl;<sub>2</sub> <span class="vector">a</span><sub><i>n</i></sub>) <br>
<span class="vector">c</span><sub><i>n</i></sub> = <span class="vector">f</span>(<span class="vector">x</span><sub><i>n</i></sub> + <sup><i>h</i></sup>&frasl;<sub>2</sub> <span class="vector">b</span><sub><i>n</i></sub>) <br>
<span class="vector">d</span><sub><i>n</i></sub> = <span class="vector">f</span>(<span class="vector">x</span><sub><i>n</i></sub> + <i>h</i> <span class="vector">c</span><sub><i>n</i></sub>) <br>
<span class="vector">x</span><sub><i>n</i>+1</sub> = <span class="vector">x</span><sub><i>n</i></sub> + <sup><i>h</i></sup>&frasl;<sub>6</sub> (<span class="vector">a</span><sub><i>n</i></sub>
+ 2 <span class="vector">b</span><sub><i>n</i></sub> + 2 <span class="vector">c</span><sub><i>n</i></sub> + <span class="vector">d</span><sub><i>n</i></sub>)
</p>

<p>El nuevo vector <span class="html-math inline-math">
<span class="vector">x</span><sub><i>n</i>+1</sub>
</span> da el estado de la simulación después del periodo de tiempo <span class="html-math inline-math">
h
</span> que ha transcurrido. Para explicar lo anterior con más detalle, podemos
suelte la notación vectorial y escriba el algoritmo de Runge-Kutta así:
</p>

<p class="html-math display-equation">
<i>x</i><sub><i>j</i>, <i>n</i></sub> = <i>f<sub>j</sub></i>(<i>x</i><sub>1,<i>n</i></sub>,  <i>x</i><sub>2,<i>n</i></sub>, . . . , <i>x</i><sub><i>m</i>,<i>n</i></sub>)<br>
<i>x</i><sub><i>j</i>, <i>n</i></sub> = <i>f<sub>j</sub></i><span class="bigg">(</span> (<i>x</i><sub>1, <i>n</i></sub> + <sup><i>h</i></sup>&frasl;<sub>2</sub> <i>x</i><sub>1, <i>n</i></sub>),  (<i>x</i><sub>2, <i>n</i></sub>
                + <sup><i>h</i></sup>&frasl;<sub>2</sub> <i>x</i><sub>2, <i>n</i></sub>), . . . , (<i>x</i><sub><i>m</i>, <i>n</i></sub>
                + <sup><i>h</i></sup>&frasl;<sub>2</sub> <i>x</i><sub><i>m</i>, <i>n</i></sub>) <span class="bigg">)</span><br>
<i>x</i><sub><i>j</i>, <i>n</i></sub> = <i>f<sub>j</sub></i><span class="bigg">(</span> (<i>x</i><sub>1,<i>n</i></sub> + <sup><i>h</i></sup>&frasl;<sub>2</sub> <i>x</i><sub>1,<i>n</i></sub>),  (<i>x</i><sub>2,<i>n</i></sub>
                + <sup><i>h</i></sup>&frasl;<sub>2</sub> <i>x</i><sub>2,<i>n</i></sub>), . . . , (<i>x</i><sub><i>m</i>,<i>n</i></sub>
                + <sup><i>h</i></sup>&frasl;<sub>2</sub> <i>x</i><sub><i>m</i>,<i>n</i></sub>) <span class="bigg">)</span><br>
<i>x</i><sub><i>j</i>, <i>n</i></sub> = <i>f<sub>j</sub></i><span class="bigg">(</span> (<i>x</i><sub>1,<i>n</i></sub> + <i>h</i> <i>x</i><sub>1,<i>n</i></sub>),  (<i>x</i><sub>2,<i>n</i></sub>
                            + <i>h</i> <i>x</i><sub>2,<i>n</i></sub>), . . . , (<i>x</i><sub><i>m</i>,<i>n</i></sub>
                            + <i>h</i> <i>x</i><sub><i>m</i>,<i>n</i></sub>) <span class="bigg">)</span><br>
<i>x</i><sub><i>j</i>, <i>n</i>+1</sub> = <i>x</i><sub><i>j</i>, <i>n</i></sub> + <sup><i>h</i></sup>&frasl;<sub>6</sub> (<i>x</i><sub><i>j</i>, <i>n</i></sub> + 2 <i>x</i><sub><i>j</i>, <i>n</i></sub>
                + 2 <i>x</i><sub><i>j</i>, <i>n</i></sub> + <i>x</i><sub><i>j</i>, <i>n</i></sub>)
</p>


<p>Las ecuaciones anteriores se aplican para cada variable <span class="html-math inline-math">
<i>j</i>=(1, ..., <i>m</i>)
</span>> para obtener el
conjunto completo de variables en el vector <span class="html-math inline-math">
<span class="vector">x</span><sub><i>n</i>+1</sub>
</span>.
</p>




<h2>El tiempo como variable</h2>

<p>La mayoría de las simulaciones que se muestran en este sitio web <em>no</em> tienen ecuaciones diferenciales
  que dependen explícitamente del tiempo. Es decir, no verás la variable
<span class="html-math inline-math">
<i>t</i>
</span> en el lado derecho de las ecuaciones diferenciales. Una simulación que
<em>depende</em> del tiempo es el
<a href="../ChaoticPendulumApp/ChaoticPendulumApp-es.html">Péndulo Caótico</a>
porque la fuerza motriz (que aplica el giro al péndulo)
varía con el tiempo según <span class="html-math inline-math">
cos(<i>k</i> <i>t</i>)
</span>.
</p>

<p>Cuando el tiempo aparece explícitamente en las ecuaciones diferenciales podemos agregar un tiempo
  variable <span class="html-math inline-math">
<i>t</i>
</span> al vector de estados <span class="html-math inline-math">
<span class="vector">x</span>
</span>. Supongamos que asignamos este rol a
la variable <span class="html-math inline-math">
<i>x<sub>2</sub></i>
</span>. Esta nueva variable tiene una ecuación diferencial extremadamente simple
</p>

<p class="html-math display-equation">
<i>x<sub>2</sub></i>' = 1
</p>

<p>Eso dice que la tasa de cambio de la variable <span class="html-math inline-math">
<i>x<sub>2</sub></i>
</span> es una constante. Ya que
estamos tomando derivadas con respecto al tiempo, también podemos escribir la ecuación anterior como
</p>

<p>$$x_2' = \frac{d}{d t} x_2 = 1$$</p>

<p>Esto se integra muy fácilmente para dar <span class="html-math inline-math">
<i>x<sub>2</sub></i> = <i>t</i>
</span>, que es lo que queríamos: tiempo
como una variable Supongamos que en la simulación del péndulo accionado configuramos <span class="html-math inline-math">
<i>x<sub>2</sub></i>
</span> de esta forma. Entonces la fuerza impulsora viene dada por <span class="html-math inline-math">
cos(<i>k</i> <i>x<sub>2</sub></i>)
</span>.
</p>


<p>Puede preguntarse: <em>¿Por qué el tiempo es una variable? Ya sabemos el valor de
<span class="html-math inline-math">
<i>t</i>
</span> en cada paso de tiempo!</em> El algoritmo de Runge-Kutta funciona promediando el
tasas pronosticadas en varios puntos en el intervalo de tiempo de <span class="html-math inline-math">
<i>t</i>
</span> a
<span class="html-math inline-math">
<i>t</i>+<i>h</i>
</span>. Por lo tanto, cuando las tasas (ecuaciones diferenciales) dependen explícitamente de
<span class="html-math inline-math">
<i>t</i>
</span>, también necesitamos saber el valor de <span class="html-math inline-math">
<i>t</i>
</span> en esos puntos
<em>dentro</em> del intervalo de tiempo. Poner el tiempo como una variable lo hace más agradable y produce un
código de computadora más limpio.
</p>


<h2>El tiempo pasó directamente</h2>

<p>Si lo desea, puede evitar mantener el tiempo como una variable adicional. El seguimiento
  es una formulación equivalente del algoritmo de Runge-Kutta donde el tiempo <span class="html-math inline-math">
<i>t</i>
</span> es
pasado como una variable a cada función en <span class="html-math inline-math">
<span class="vector">f</span>
</span>.
</p>

<p class="html-math display-equation">
<span class="vector">a</span><sub><i>n</i></sub> = <span class="vector">f</span>(<i>t</i>, <span class="vector">x</span><sub><i>n</i></sub>) <br>
<span class="vector">b</span><sub><i>n</i></sub> = <span class="vector">f</span>(<i>t</i> + <sup><i>h</i></sup>&frasl;<sub>2</sub>, <span class="vector">x</span><sub><i>n</i></sub> + <sup><i>h</i></sup>&frasl;<sub>2</sub> <span class="vector">a</span><sub><i>n</i></sub>) <br>
<span class="vector">c</span><sub><i>n</i></sub> = <span class="vector">f</span>(<i>t</i> + <sup><i>h</i></sup>&frasl;<sub>2</sub>, <span class="vector">x</span><sub><i>n</i></sub> + <sup><i>h</i></sup>&frasl;<sub>2</sub> <span class="vector">b</span><sub><i>n</i></sub>) <br>
<span class="vector">d</span><sub><i>n</i></sub> = <span class="vector">f</span>(<i>t</i> + <i>h</i>, <span class="vector">x</span><sub><i>n</i></sub> + <i>h</i> <span class="vector">c</span><sub><i>n</i></sub>) <br>
<span class="vector">x</span><sub><i>n</i>+1</sub> = <span class="vector">x</span><sub><i>n</i></sub> + <sup><i>h</i></sup>&frasl;<sub>6</sub> (<span class="vector">a</span><sub><i>n</i></sub>
+ 2 <span class="vector">b</span><sub><i>n</i></sub> + 2 <span class="vector">c</span><sub><i>n</i></sub> + <span class="vector">d</span><sub><i>n</i></sub>) <br>
</p>

<p>Esto es equivalente a la formulación donde el tiempo se mantiene como una de las variables en
<span class="html-math inline-math">
<span class="vector">x</span>
</span>. Ya sea que use esta formulación o la anterior (más limpia) es
completamente decisión tuya.
</p>


<p>El <a href="https://github.com/myphysicslab/myphysicslab/blob/master/src/lab/model/RungeKutta.js">código fuente del algoritmo Runge-Kutta</a> está disponible en el repositorio.
</p>

<p id="page_history">
  Esta página web se publicó por primera vez en abril de 2001.
</p>


<div id="footer2" >
  <div id="copyright">
    &copy; <a href="mailto:erikn@myPhysicsLab.com"
    title="send comments to Erik Neumann">
    Erik Neumann</a>,  2004-2016<br>
    <span id="revised_date">revisado Feb 6 2021</span>
  </div>
  <a class="nav_link" href="numerical-solution-es.html">previous</a>
  <a class="nav_link" href="math-refresh-es.html">next</a>
</div>
</body>
</html>
