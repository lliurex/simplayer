<!DOCTYPE html>
<html lang="es">
<head>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="stylesheet.css">
<link rel="stylesheet" type="text/css" href="../common/stylesheet1.css">
<title>Bloques Chocando</title>

<script>
  document.getElementsByTagName("html")[0].style.visibility = "hidden";
</script>
</head>
<body>

  <h1>Bloques Chocando</h1>

<ul id="header_bar" class="horiz_tabs">
  <li class="sim selected">Simulador</li>
  <li class="graph ">Gráfico</li>
  <li class="time_graph">Gráfico de tiempo</li>
  <li class="multi_graph">Gráfico múltiple</li>
</ul>

<div id="container" class="control_container">
  <div id="div_graph" >
  </div>
  <div id="div_time_graph" >
  </div>
  <div id="sim_applet" >
  </div>
  <div id="sim_controls" class="control_group">
  </div>
  <div id="graph_controls" class="control_group">
  </div>
  <div id="time_graph_controls" class="control_group">
  </div>
  <p>
  <label id="label_show_sim">
    <input type="checkbox" id="show_sim">show sim
  </label>
   <label id="label_terminal">
    <input type="checkbox" id="show_terminal">terminal
   </label>
   <div id="div_terminal">
     <textarea id="term_output" cols=80 rows=20 wrap="soft"></textarea> <br>
     <label style="display:inline-block">command &gt;
       <input type="text" id="term_input" size="80">
     </label>
   </div>
</div>

<script type="text/javascript" async
  src="../../mathjax/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<h2>Acerca de</h2>

<p class="instructions">
  Puede cambiar parámetros como la masa, la rigidez del resorte y la fricción (amortiguación). Tú
  Puede arrastrar cualquiera de los bloques con el mouse para cambiar las posiciones iniciales.
</p>

<p>Los cálculos matemáticos detrás de la simulación se muestran a continuación. También está disponible:
<a href="https://github.com/myphysicslab/myphysicslab/blob/master/src/sims/springs/CollideBlocksApp.js">código fuente</a>,
documentación y un
versión compilada simple
que es más personalizable.
</p>

<h2 id="momentum">Colisiones y conservación de la cantidad de movimiento</h2>

<p>El resorte y el bloque de la izquierda usan el mismo modelo que la
<a href="../SingleSpringApp/SingleSpringApp-es.html">simulación de muelle único</a>.
Para una colisión con la pared,
simplemente invertimos la velocidad. Para colisiones entre bloques en movimiento usamos la ley de
conservación de la cantidad de movimiento para determinar las nuevas velocidades.
</p>

<p>Se definen las siguientes variables:</p>

<ul class="vars">
    <li><span class="html-math inline-math">
<i>v</i><sub>1i</sub>, <i>v</i><sub>2i</sub> =
</span> velocidad inicial (antes de la colisión) de los bloques</li>
    <li><span class="html-math inline-math">
<i>v</i><sub>1f</sub>, <i>v</i><sub>2f</sub> =
</span> velocidad final (posterior a la colisión) de los bloques</li>
    <li><span class="html-math inline-math">
<i>v</i><sub>cm</sub> =
</span> velocidad del centro de masa</li>
    <li><span class="html-math inline-math">
<i>v</i><sub>1cm</sub>, <i>v</i><sub>2cm</sub> =
</span> velocidad de los bloques en el centro del marco de masa</li>
    <li><span class="html-math inline-math">
<i>m</i><sub>1</sub>, <i>m</i><sub>2</sub> =
</span> masa de bloques</li>
    <li><span class="html-math inline-math">
<i>p</i><sub>i</sub>, <i>p</i><sub>f</sub> =
</span> cantidad de movimiento inicial y final del sistema de bloques</li>
</ul>

<p>Encontramos la velocidad del centro de masa del sistema de 2 bloques.</p>

<div class="html-math table-equation">
<table class="fraction">
    <tr>
        <td rowspan="2">
            <i>v</i><sub>cm</sub> = &nbsp;
        </td><td>
            <i>m</i><sub>1</sub> <i>v</i><sub>1i</sub> + <i>m</i><sub>2</sub> <i>v</i><sub>2i</sub>
        </td>
    </tr><tr>
        <td class="upper_line">
            <i>m</i><sub>1</sub> + <i>m</i><sub>2</sub>
        </td>
    </tr>
</table>
</div>

<p>Luego encontramos la velocidad de cada bloque en el sistema de coordenadas (marco) que está
  moviéndose junto con el centro de masas.</p>

<p class="html-math display-equation">
<i>v</i><sub>1cm</sub> = <i>v</i><sub>1i</sub> &minus; <i>v</i><sub>cm</sub><br>
<i>v</i><sub>2cm</sub> = <i>v</i><sub>2i</sub> &minus; <i>v</i><sub>cm</sub>
</p>

<p>A continuación, reflejamos (invertimos) cada velocidad en este marco del centro de masa y trasladamos
  de vuelta al sistema de coordenadas estacionario.</p>

<p class="html-math display-equation">
<i>v</i><sub>1f</sub> = &minus;(<i>v</i><sub>1i</sub> &minus; <i>v</i><sub>cm</sub>) + <i>v</i><sub>cm</sub><br>
<i>v</i><sub>2f</sub> = &minus;(<i>v</i><sub>2i</sub> &minus; <i>v</i><sub>cm</sub>) + <i>v</i><sub>cm</sub>
</p>

<p>Si expande completamente lo anterior obtendrá</p>

<table class="html-math numbered-equation">
<tr><td class="equation-number">&nbsp;&nbsp;</td><td>
<table class="fraction">
    <tr>
        <td rowspan="2">
            <i>v</i><sub>1f</sub> = &minus;<i>v</i><sub>1i</sub> + &nbsp;
        </td><td>
            2(<i>m</i><sub>1</sub> <i>v</i><sub>1i</sub> + <i>m</i><sub>2</sub> <i>v</i><sub>2i</sub>)
        </td>
    </tr><tr>
        <td class="upper_line">
            <i>m</i><sub>1</sub> + <i>m</i><sub>2</sub>
        </td>
    </tr>
</table>

</td><td class="equation-number">(1)</td></tr></table>

<table class="html-math numbered-equation">
<tr><td class="equation-number">&nbsp;&nbsp;</td><td>
<table class="fraction">
    <tr>
        <td rowspan="2">
            <i>v</i><sub>2f</sub> = &minus;<i>v</i><sub>2i</sub> + &nbsp;
        </td><td>
            2(<i>m</i><sub>1</sub> <i>v</i><sub>1i</sub> + <i>m</i><sub>2</sub> <i>v</i><sub>2i</sub>)
        </td>
    </tr><tr>
        <td class="upper_line">
            <i>m</i><sub>1</sub> + <i>m</i><sub>2</sub>
        </td>
    </tr>
</table>

</td><td class="equation-number">(2)</td></tr></table>

<p>Como verificación, podemos calcular el momento anterior y posterior a la colisión, que debe ser
  lo mismo.</p>

<p class="html-math display-equation">
<i>p</i><sub>i</sub> = <i>m</i><sub>1</sub> <i>v</i><sub>1i</sub> + <i>m</i><sub>2</sub> <i>v</i><sub>2i</sub><br>
<i>p</i><sub>f</sub> = <i>m</i><sub>1</sub> <i>v</i><sub>1f</sub> + <i>m</i><sub>2</sub> <i>v</i><sub>2f</sub>
</p>


<p>Si expande <span class="html-math inline-math">
<i>p</i><sub>f</sub>
</span> usando las ecuaciones (1) y (2) y simplificando verás que
<span class="html-math inline-math">
<i>p</i><sub>f</sub> = <i>p</i><sub>i</sub>
</span> como se esperaba.</p>




<h2 id="collisions">Gestión de colisiones en el software</h2>

<div class="image" style="width: 175px;">
<img src="collision.gif" width="172" height="228" alt="">
<br>
<br>
simulación de dos bolas chocando
</div>

<div style="margin-left: 180px; max-width: 40em;">

<p>Las simulaciones en la computadora son discretas en el sentido de que el tiempo avanza en
  "trozos", no sin problemas. En el diagrama, calculamos el estado del mundo en el momento
<span class="html-math inline-math">
<i>t</i> = 10.0
</span> y luego en el momento <span class="html-math inline-math">
<i>t</i> = 10.1
</span>. Pero la colisión
sucedió en algún momento intermedio. Entonces, cuando detectamos una colisión, los objetos están
superponiéndose entre sí, un estado físicamente imposible.</p>

<p>Las simulaciones en este sitio web manejan las colisiones de la siguiente forma:</p>

<ul>

  <li>Detectar que ocurrió una colisión</li>

  <li>Se vuelve a ejecutar la simulación muy cerca (pero justo antes) del momento de la colisión.
    El momento de la colisión se encuentra mediante un proceso de búsqueda binaria.</li>

  <li>Se controla la colisión modificando el estado de la simulación, corrigiendo
    las velocidades como se describe arriba.</li>

  <li>Se continua ejecutando la simulación hasta el momento actual 'ahora'. Si adicionalmente
    las colisiones ocurren, se manejan de la misma forma.</li>

</ul>

</div>

<p style="clear:both;">
  Si no se está ejecutando la simulación en tiempo real, se puede tomar el tiempo que se desee
  obteniendo tanta precisión como se desee, pero para una simulación en tiempo real, es posible que se deba aceptar
  menor precisión o utilizar una programación más sofisticada. Por ejemplo, en lugar de usar prueba y
  error para encontrar el momento de la colisión, se podría intentar predecir el momento de la colisión
  según el estado del sistema.</p>


<p>Otros ejemplos de simulaciones con manejo de colisiones son
<a href="../RollerFlightApp/RollerFlightApp-es.html#collision_time">Montaña Rusa con Vuelo</a>,
<a href="../Molecule1App/Molecule1App-es.html">Molécula 2</a> and
<a href="../ImpulseApp/ImpulseApp-es.html">Colisiones de Cuerpo Rígido</a>.
</p>

<p id="page_history">
  Esta página web se publicó por primera vez en abril de 2001.
</p>

<div id="footer2" >
  <div id="copyright">
    &copy; <a href="mailto:erikn@myPhysicsLab.com"
    title="send comments to Erik Neumann">
    Erik Neumann</a>,  2004-2016<br>
    <span id="revised_date">revisado Feb 6 2021</span>
  </div>
</div>

<!-- Call the app script after the body so that html entities are defined and
* the script can find them.-->
<script src="CollideBlocksApp-es.js"></script>

<script>
  (function build() {
    var elem_ids = {
      tab_list: 'header_bar',
      container: 'container',
      term_output: 'term_output',
      term_input: 'term_input',
      sim_applet: 'sim_applet',
      div_graph: 'div_graph',
      graph_controls: 'graph_controls',
      sim_controls: 'sim_controls',
      div_terminal: 'div_terminal',
      div_time_graph: 'div_time_graph',
      time_graph_controls: 'time_graph_controls',
      div_multi_graph: 'div_multi_graph',
      multi_graph_controls: 'multi_graph_controls',
      label_terminal: 'label_terminal',
      show_terminal: 'show_terminal',
      show_sim: 'show_sim',
      images_dir: '../common'
    };
    app = makeCollideBlocksApp(elem_ids);
    app.defineNames('app');
    window.addEventListener('pageshow', function(event){
      // set language menu and compiled menus in case of back-button
      var menu = document.getElementById('language_menu');
      if (menu) { menu.selectedIndex = 2; }
      menu = document.getElementById('compiled_menu');
      if (menu) { menu.selectedIndex = 1; }
    }, /*capturing=*/false);
    window.addEventListener('blur', function(event){
      app.eval('FIRING=false;', /*output=*/false);
    }, /*capturing=*/false);
    window.addEventListener('focus', function(event){
      app.eval('FIRING=true;', /*output=*/false);
    }, /*capturing=*/false);
  }());
</script>

<script>
  document.getElementsByTagName("html")[0].style.visibility = "visible";
</script>

<script>var app; if (app) app.setup();</script>
<script>var app; if (app) app.start();</script>
<div id="footer2" >
  <div id="copyright">
    &copy; <a href="mailto:erikn@MyPhysicsLab.com"
    title="copyright 2020 Erik Neumann">
    Erik Neumann</a> 2020, available under
    <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2</a>
</div>
</body>
</html>
