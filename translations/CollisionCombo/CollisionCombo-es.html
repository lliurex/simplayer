<!DOCTYPE html>
<html lang="es">
<head>
<title lang="es">Múltiples Colisiones Simultáneas</title>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../common/stylesheet1.css">

<script>
  document.getElementsByTagName("html")[0].style.visibility = "hidden";
</script>
</head>
<body>

<!--Collision Handling Methods
* Kollision Bearbeitung Methoden
-->

<h1>Múltiples Colisiones Simultáneas</h1>

<div id="header_nav">
</div>
<ul id="header_bar">
</ul>


<!--p><b>(TO DO: ADD REFERENCE TO PAGE ABOUT JOINTS WHEN WE HAVE ONE.)</b></p-->

<p class="introduction">Esta página explica cómo el
<a href="../explain/physics-engine-es.html">Motor de Física de Cuerpo Rígido 2D</a>.
se ocupa de múltiples colisiones simultáneas. Los puntos de resumen son:
</p>

<ul>
  <li>Las colisiones se eligen al azar y se manejan una a la una cada vez, hasta que no haya
    colisiones restantes.</li>

  <li>Los impulsos de colisión y sus efectos resultantes se acumulan hasta que todos
    las colisiones se resuelven (sin salir de la rutina de manejo de colisiones).</li>

  <li>Las articulaciones son un caso especial, se manejan a través de un método de colisión "simultánea".</li>

  <li>Las colisiones cuadradas que involucran formas rectangulares quizás no sean correctas.</li>
</ul>



<p>Las simulaciones discutidas aquí usan reglas simplificadas para determinar el resultado de una
  colisión. Una simulación más exacta modelaría la deformación de los cuerpos en colisión.
  en una escala de tiempo muy pequeña. Pero eso requeriría un software y modelos mucho más complejo, además no se ejecutaría de forma interactiva en tiempo real.
</p>

<p>El resultado final: aunque no existe una única solución perfecta, para la mayoría de los propósitos
  el método <a href="#serial">manejo de colisiones en serie</a> funciona bastante bien.</p>

<p>El libro <i>Physics-Based Animation</i> de Erleben, Sporring, Henriksen y Dohlmann
  discute varios enfoques para manejar las colisiones. Al comparar dos de los métodos
  considerados a continuación, escriben (en la página 153):
</p>

<p class="quote">
  Realmente no podemos hablar de que un método sea más correcto o mejor que el otro,
  porque es posible establecer configuraciones físicas de cuerpos rígidos en colisión
  donde uno de los métodos calcula el movimiento deseado y el otro no y viceversa.
</p>

<h2>Colisiones simples</h2>

<p>La teoría de las colisiones de cuerpos rígidos se describe en
<a href="../ImpulseApp/ImpulseApp-es.html#collision_physics">Física de Colisión para Cuerpos Rígidos en 2
  Dimensiones</a>. Ahí se describe una sola colisión entre dos cuerpos en una colisión.
  puntual.</p>

<p>La idea clave es que podemos encontrar un
<a href="../ImpulseApp/ImpulseApp-es.html#collision_impulse">impulso de colisión</a> que invierta la
colisión tal que la velocidad relativa final entre los cuerpos, <span class="html-math inline-math">
<i>v<sub>f</sub></i>
</span>, después de
la colisión sea un múltiplo de la velocidad relativa inicial, <span class="html-math inline-math">
<i>v<sub>i</sub></i>
</span>.
</p>

<div id="equation1">
<table class="html-math numbered-equation">
<tr><td class="equation-number">&nbsp;&nbsp;</td><td>
<i>v<sub>f</sub></i> = &minus;<i>e</i> <i>v<sub>i</sub></i>

</td><td class="equation-number">(1)</td></tr></table>
</div>

<p>La velocidad aquí es la velocidad a la que la distancia entre los objetos está
  cambiando &ndash; <em>su velocidad relativa entre sí</em> (no la velocidad absoluta
  de los objetos en relación con el fondo fijo).</p>

<ul>
  <li>Velocidad relativa negativa significa que los objetos están chocando: el espacio entre ellos
    se está volviendo más pequeño.</li>

  <li>Velocidad relativa positiva significa que los objetos se están separando: el espacio entre ellos
    se está haciendo más grande.</li>
</ul>

<p>La elasticidad <span class="html-math inline-math">
<i>e</i>
</span> es una constante entre 0 y 1 que indica qué tan "rebotante"
es la colisión, donde <span class="html-math inline-math">
<i>e</i> = 1
</span> significa perfectamente elástico y <span class="html-math inline-math">
<i>e</i> = 0
</span> significa
completamente inelástico.
<!--For <span class="html-math inline-math">
<i>e</i> = 1
</span> the relative velocity after the collision is the exact opposite of the velocity before the collision.-->
</p>



<h2>Colisiones Múltiples</h2>

<p>Cuando hay múltiples puntos de contacto simultáneos entre dos o más cuerpos
  tenemos que modificar el algoritmo de manejo de colisiones.</p>

<p>Un caso típico es cuando varios cuerpos están en contacto entre sí y en reposo,
  luego otro cuerpo choca contra un miembro del grupo. Piense en la "ruptura" inicial en
  un <a href="../BilliardsApp/BilliardsApp-es.html">juego de billar</a> donde una bola choca con un gran
  grupo de bolas que están en contacto entre sí y en reposo.
</p>

<p>Otro caso son las múltiples colisiones simultáneas. Un caso típico es un bloque rectangular
  chocando contra una pared de tal manera que ambas esquinas chocan. Otro caso son dos
  cuerpos chocando desde direcciones separadas en un tercer cuerpo.</p>

<p>Hay dos formas de lidiar con colisiones múltiples</p>

<ol>
  <li><b>Manejo de colisiones simultáneas.</b> Todas las velocidades resultantes son
    calculadas en un solo paso.</li>

  <li><b>Gestión de colisiones en serie o secuenciales.</b> Cada colisión se resuelve en
    turnos como si fuera una sola colisión. El orden de resolución de las colisiones es
    aleatorio, su efecto se suma, y ​​cada colisión puede causar que otras colisiones que
    ocurren se resuelvan instantáneamente durante este proceso.</li>

</ol>


<h2 id="simultaneous">Manejo de colisiones simultáneas</h2>

<p>Un método para manejar múltiples colisiones se llama <i> el método de colisiones simultaneo </i>.
  En este caso, predecimos el resultado en cada punto de
colisión o contacto usando la <a href="#equation1">ecuación (1)</a>. Entonces
encuentramos que el impulso de colisión apropiado en cada punto de colisión es el que
el resultado final coincide con lo que predice la ecuación (1).
</p>

<p>Considere una situación en la que hay dos discos de hockey en reposo y en contacto entre sí;
  y luego un tercer disco viene desde la izquierda y golpea uno de los discos.
  (Imagínese que estamos mirando hacia abajo sobre una mesa de air hockey).
</p>


<div id="container1" class="control_container" lang="es">
  <div id="div_graph1" >
  </div>
  <div id="div_time_graph1" >
  </div>
  <div id="sim_applet1" >
  </div>
  <div id="sim_controls1" class="control_group">
  </div>
  <div id="graph_controls1" class="control_group">
  </div>
  <div id="time_graph_controls1" class="control_group">
  </div>
  <p>
  <label id="label_show_sim1">
    <input type="checkbox" id="show_sim1">show sim
  </label>
  <label id="label_terminal1">
    <input type="checkbox" id="show_terminal1">terminal
  </label>
  <div id="div_terminal1">
    <textarea id="term_output1" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input1" size="80">
    </label>
  </div>
</div>

<p>Suponemos que estos discos de hockey están exactamente alineados, la elasticidad es 1 y los discos
  tienen la misma masa. Hay dos puntos de colisión, la colisión de la izquierda tiene un
<span class="html-math inline-math">
<i>v<sub>i</sub></i> = &minus;2
</span>, la colisión derecha tiene <span class="html-math inline-math">
<i>v<sub>i</sub></i> = 0
</span>. Al usar la <a
href="#equation1">ecuación (1)</a> obtenemos para la colisión izquierda <span class="html-math inline-math">
<i>v<sub>f</sub></i> = 2
</span> y
para la colisión derecha <span class="html-math inline-math">
<i>v<sub>f</sub></i> = 0
</span>. Entonces vemos que el disco izquierdo rebota hacia la
izquierda y el par de discos se mueven a la derecha permaneciendo juntos.
</p>

<p>¡Este es el comportamiento incorrecto! Si juegas al billar, sabes lo que debe pasar: los discos
  de la izquierda y del medio deben permanecer estacionarios, y el disco de la extrema derecha debe moverse
  lejos. Otro ejemplo del comportamiento correcto se ve en el juguete llamado  <a
href="../NewtonsCradleApp/NewtonsCradleApp-es.html">Cuna de Newton</a>. Es un conjunto de bolas de acero suspendidas
de cuerdas, de modo que estén apoyadas una contra la otra; cuando tomas una de
las bolas del final y dejas que golpee el grupo, esa bola se detiene y la bola en el
el otro extremo se va volando.
</p>

<p>Considere solo dos discos de hockey, uno estacionario y el otro moviéndose desde la izquierda.
  Supongamos que tienen la misma masa, son perfectamente elásticos (<span class="html-math inline-math">
<i>e</i> = 1
</span>), y el movimiento está alineado para que golpeen de lleno. Después de que choquen, el disco izquierdo debe estar
estacionario, y el disco derecho debe alejarse. Debido a que esta es una sola colisión, la <a
href="#equation1">ecuación (1)</a> da el resultado correcto, con <span class="html-math inline-math">
<i>v<sub>f</sub></i> = &minus;<i>v<sub>i</sub></i>
</span>,
y esto es lo que vemos en la simulación de discos de hockey. En el caso de tres discos de hockey, debería ocurrir lo mismo:
la velocidad debería transferirse del disco izquierdo al disco derecho, con el impacto transferido a través del disco central.
</p>


<div id="container2" class="control_container" lang="es">
  <div id="div_graph2" >
  </div>
  <div id="div_time_graph2" >
  </div>
  <div id="sim_applet2" >
  </div>
  <div id="sim_controls2" class="control_group">
  </div>
  <div id="graph_controls2" class="control_group">
  </div>
  <div id="time_graph_controls2" class="control_group">
  </div>
  <p>
  <label id="label_show_sim2">
    <input type="checkbox" id="show_sim2">show sim
  </label>
  <label id="label_terminal2">
    <input type="checkbox" id="show_terminal2">terminal
  </label>
  <div id="div_terminal2">
    <textarea id="term_output2" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input2" size="80">
    </label>
  </div>
</div>


<p>Otra forma de ver esto: ¿Qué pasa si los dos discos estacionarios no se tocan del todo,
  pero hay una pequeña brecha entre ellos? Entonces, lo que pasa es que el "uno colisiona con otro"
  ocurre dos veces, separadas por una pequeña brecha de tiempo y espacio, el disco de hockey
  de la siguiente simulación demuestra esto. Como se puede hacer que este espacio sea tan pequeño como se desee,
  parece irrazonable que el comportamiento cambie de repente dramáticamente cuando los discos
  se tocan en lugar de estar separados por un pequeño espacio.
</p>


<div id="container3" class="control_container" lang="es">
  <div id="div_graph3" >
  </div>
  <div id="div_time_graph3" >
  </div>
  <div id="sim_applet3" >
  </div>
  <div id="sim_controls3" class="control_group">
  </div>
  <div id="graph_controls3" class="control_group">
  </div>
  <div id="time_graph_controls3" class="control_group">
  </div>
  <p>
  <label id="label_show_sim3">
    <input type="checkbox" id="show_sim3">show sim
  </label>
  <label id="label_terminal3">
    <input type="checkbox" id="show_terminal3">terminal
  </label>
  <div id="div_terminal3">
    <textarea id="term_output3" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input3" size="80">
    </label>
  </div>
</div>



<h2 id="serial">Manejo de colisiones en serie</h2>

<div class="image" style="width: 202px; float: left;">
<img src="collision_handling_2.png" width="201" height="255" alt=""><br>
secuencia de colisiones
</div>

<div style="margin-left: 228px; max-width: 40em;">
<p>El método de manejo de colisiones <i>en serie</i> también se conoce con el nombre de método de manejo de colisiones con
<i>propagación de impulsos</i> o <i>secuencial</i>. Con el método en serie, imaginamos que cada una de las colisiones múltiples ocurren cada una a la vez en
secuencia; resolvemos cada colisión como una sola colisión y luego en base a las
velocidades resultantes si hay colisiones posteriores para resolver. Todo esto pasa
instantáneamente. Es como imaginar que hay pequeños espacios entre los
objetos y que rebotan unos contra otros después de que ocurra la colisión inicial.
</p>

<p>Considere el escenario "uno golpea dos", donde un disco golpea dos discos inmóviles que
  están en contacto. Con el método simultáneo, usamos <a href="#equation1">la ecuación (1)</a>
  para decidir de antemano cuáles serían las velocidades finales en las dos puntos de colisión (esto se describió anteriormente).
  El método en serie pasa por un proceso de "solucionador de colisiones" donde los objetos chocan y rebotan entre sí, posiblemente muchas veces,
  hasta que no haya más colisiones. Este proceso de resolución de colisiones no lleva tiempo,
  la idea es que debido a que los objetos están todos en contacto, no hay distancia para
  que viajen para chocar unos con otros.
</p>

<p>Con el método de manejo de colisiones en serie, cuando la elasticidad <span class="html-math inline-math">
<i>e</i> = 1
</span>, el escenario "uno
golpea dos" es así: suponga que el disco izquierdo se acerca a los dos discos estacionarios con <span class="html-math inline-math">
<i>v<sub>i</sub></i> = &minus;2
</span>
</p>

<ul>
  <li>primera colisión: el disco izquierdo golpea el disco central,  <span class="html-math inline-math">
<i>v<sub>f</sub></i> = &minus;<i>v<sub>i</sub></i> = 2
</span>, (esto es
lo mismo que en el escenario "uno colisiona con otro")</li>

  <li>segunda colisión: el disco central golpea el disco derecho con <span class="html-math inline-math">
<i>v<sub>i</sub></i> = &minus;2
</span>, (otra vez lo mismo, como el escenario "uno colisiona con otro")</li>

</ul>

<p>El resultado es que los discos izquierdo y central están fijos y <span class="html-math inline-math">
<i>v<sub>f</sub></i> = 2
</span> para la segunda colisión. La siguiente simulación ejecuta este escenario con el método de colisión en serie;
muestra que el método en serie maneja correctamente este caso, en contraste con el método simultáneo.
</p>
</div>

<div style="clear: both;">


<div id="container4" class="control_container" lang="es">
  <div id="div_graph4" >
  </div>
  <div id="div_time_graph4" >
  </div>
  <div id="sim_applet4" >
  </div>
  <div id="sim_controls4" class="control_group">
  </div>
  <div id="graph_controls4" class="control_group">
  </div>
  <div id="time_graph_controls4" class="control_group">
  </div>
  <p>
  <label id="label_show_sim4">
    <input type="checkbox" id="show_sim4">show sim
  </label>
  <label id="label_terminal4">
    <input type="checkbox" id="show_terminal4">terminal
  </label>
  <div id="div_terminal4">
    <textarea id="term_output4" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input4" size="80">
    </label>
  </div>
</div>

<p>Dato curioso: Con elasticidad <span class="html-math inline-math">
<i>e</i> = 1.
</span> solo tuvimos 2 colisiones en el
secuencia. Pero con menor elasticidad, como <span class="html-math inline-math">
<i>e</i> = 0.8
</span>, terminas con una serie infinita de colisiones cada vez más pequeñas a medida que el disco central choca hacia atrás y
adelante entre los discos izquierdo y derecho.
</p>
</div>


<h2>Problemas con colisiones en serie.</h2>

<p>El "problema" más obvio con las colisiones en serie es cuando tenemos un bloque cuadrado
  en lugar de una bola redonda, y las dos esquinas del bloque golpean un borde al mismo tiempo.
  Aquí hay una simulación de esto; primero con el manejo de colisiones en serie y luego
  con manejo de colisión simultánea. ¿Cuál crees que es más realista?
</p>


<div id="container5" class="control_container" lang="es">
  <div id="div_graph5" >
  </div>
  <div id="div_time_graph5" >
  </div>
  <div id="sim_applet5" >
  </div>
  <div id="sim_controls5" class="control_group">
  </div>
  <div id="graph_controls5" class="control_group">
  </div>
  <div id="time_graph_controls5" class="control_group">
  </div>
  <p>
  <label id="label_show_sim5">
    <input type="checkbox" id="show_sim5">show sim
  </label>
  <label id="label_terminal5">
    <input type="checkbox" id="show_terminal5">terminal
  </label>
  <div id="div_terminal5">
    <textarea id="term_output5" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input5" size="80">
    </label>
  </div>
</div>

<p>Arriba está el manejo de colisiones en serie. A continuación se muestra la misma situación con
  manejo de colisiones simultáneas.
</p>


<div id="container6" class="control_container" lang="es">
  <div id="div_graph6" >
  </div>
  <div id="div_time_graph6" >
  </div>
  <div id="sim_applet6" >
  </div>
  <div id="sim_controls6" class="control_group">
  </div>
  <div id="graph_controls6" class="control_group">
  </div>
  <div id="time_graph_controls6" class="control_group">
  </div>
  <p>
  <label id="label_show_sim6">
    <input type="checkbox" id="show_sim6">show sim
  </label>
  <label id="label_terminal6">
    <input type="checkbox" id="show_terminal6">terminal
  </label>
  <div id="div_terminal6">
    <textarea id="term_output6" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input6" size="80">
    </label>
  </div>
</div>

<p>¿Es esto realmente un problema con el manejo de colisiones en serie? Sería muy raro hacer
  que ocurra una colisión de esta forma matemáticamente precisa donde ambas esquinas están
  chocando con exactamente la misma velocidad. Con un pequeño cambio en el ángulo del bloque, el
  el manejo de colisiones simultáneas produce prácticamente el mismo resultado que el manejo en serie
  como se ve en la siguiente simulación:
</p>


<div id="container7" class="control_container" lang="es">
  <div id="div_graph7" >
  </div>
  <div id="div_time_graph7" >
  </div>
  <div id="sim_applet7" >
  </div>
  <div id="sim_controls7" class="control_group">
  </div>
  <div id="graph_controls7" class="control_group">
  </div>
  <div id="time_graph_controls7" class="control_group">
  </div>
  <p>
  <label id="label_show_sim7">
    <input type="checkbox" id="show_sim7">show sim
  </label>
  <label id="label_terminal7">
    <input type="checkbox" id="show_terminal7">terminal
  </label>
  <div id="div_terminal7">
    <textarea id="term_output7" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input7" size="80">
    </label>
  </div>
</div>

<p>Anteriormente, al analizar el escenario "uno colisiona con dos", usamos el principio de que
  "pequeñas variaciones no deberían cambiar radicalmente la solución". Si aplicamos ese principio
  aquí, entonces el manejador de colisiones en serie parece ser el mejor de los dos.
</p>


<p>A continuación se muestra una situación en la que un objeto choca contra otros dos objetos al mismo tiempo.
  De nuevo se da el caso de que el método en serie da un resultado no simétrico, donde
  las dos colisiones reciben impulsos diferentes porque una se resuelve antes que la otra. Si
  elige "simultáneo" en el menú de manejo de colisiones, verá que el
  solucionador simultáneo da un buen resultado simétrico. Sin embargo, si pones una pequeño
  ángulo inicial (como 0.01) para el bloque izquierdo, entonces el resultado es similar a lo que el
  produce el método en serie.
</p>


<div id="container8" class="control_container" lang="es">
  <div id="div_graph8" >
  </div>
  <div id="div_time_graph8" >
  </div>
  <div id="sim_applet8" >
  </div>
  <div id="sim_controls8" class="control_group">
  </div>
  <div id="graph_controls8" class="control_group">
  </div>
  <div id="time_graph_controls8" class="control_group">
  </div>
  <p>
  <label id="label_show_sim8">
    <input type="checkbox" id="show_sim8">show sim
  </label>
  <label id="label_terminal8">
    <input type="checkbox" id="show_terminal8">terminal
  </label>
  <div id="div_terminal8">
    <textarea id="term_output8" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input8" size="80">
    </label>
  </div>
</div>


<h2>Bucle infinito con gestión de colisiones en serie</h2>

<p>El manejo de colisiones en serie puede resultar en un ciclo infinito de colisiones. Aquí mostramos
  un par de estos escenarios tomados de
<i>Physics-Based Animation</i> de Erleben, Sporring, Henriksen y Dohlmann,
sección 6.2.1 "No terminación de la resolución de colisión secuencial" en la página 154.</p></p>

<p>El primer ejemplo muestra dos bolas de billar envueltas en un marco, con una elasticidad perfecta de 1.0
  , si un objeto golpea el marco, entonces la secuencia de colisiones
  "envuelve" y nunca termina.</p>



<div id="container16" class="control_container" lang="es">
  <div id="div_graph16" >
  </div>
  <div id="div_time_graph16" >
  </div>
  <div id="sim_applet16" >
  </div>
  <div id="sim_controls16" class="control_group">
  </div>
  <div id="graph_controls16" class="control_group">
  </div>
  <div id="time_graph_controls16" class="control_group">
  </div>
  <p>
  <label id="label_show_sim16">
    <input type="checkbox" id="show_sim16">show sim
  </label>
  <label id="label_terminal16">
    <input type="checkbox" id="show_terminal16">terminal
  </label>
  <div id="div_terminal16">
    <textarea id="term_output16" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input16" size="80">
    </label>
  </div>
</div>

<p>La simulación aquí solo puede hacer frente a esta situación debido a algún error del
  código de manejo: cuando se detectan demasiadas iteraciones, el tamaño de la aceptable
  "pequeña velocidad" se duplica; en el caso anterior, esto sucede bastantes veces hasta que la "pequeña
  velocidad" es mayor que la velocidad de colisión original real y salimos del bucle.
  Tenga en cuenta que <em>la energía no se conserva</em> en este escenario, lo que es otro
  indicio de que esta simulación no es correcta.</p>

<p>El código de manejo de errores solo ocurre con los métodos de colisión "lastpass":
  <em>último paso agrupado en serie</em> o <em>último paso separado en serie</em>. Si tu eliges
  en su lugar, <em>grupo en serie</em> o <em>en serie separado</em> y reinicias la simulación
  (haga clic en el botón de rebobinado y luego en el botón de reproducción) recibirá una alerta de error
  cuando ocurra la colisión.</p>

<p>Otro ejemplo de Erleben, y los otros, es el de una bola pesada (masa 1000) que golpea una
  bola ligera (masa 1) que está en reposo contra una pared. Con elasticidad cero hay una secuencia
  de colisiones donde la velocidad cambia por un factor de 1000/1001 con cada colisión,
  por lo que el número de colisiones es casi infinito.</p>


<div id="container17" class="control_container" lang="es">
  <div id="div_graph17" >
  </div>
  <div id="div_time_graph17" >
  </div>
  <div id="sim_applet17" >
  </div>
  <div id="sim_controls17" class="control_group">
  </div>
  <div id="graph_controls17" class="control_group">
  </div>
  <div id="time_graph_controls17" class="control_group">
  </div>
  <p>
  <label id="label_show_sim17">
    <input type="checkbox" id="show_sim17">show sim
  </label>
  <label id="label_terminal17">
    <input type="checkbox" id="show_terminal17">terminal
  </label>
  <div id="div_terminal17">
    <textarea id="term_output17" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input17" size="80">
    </label>
  </div>
</div>

<p>Nuevamente, la simulación solo puede hacer frente a este escenario debido al error.
  El código de manejo que detecta un bucle infinito y luego afloja la precisión.</p>





<h2>Un método híbrido: entre en serie y simultáneo.</h2>

<div class="image" style="width: 227px; float: left;">
<img src="collision_handling_1.png" width="226" height="318" alt=""><br>
secuencia de colisiones
</div>

<div style="margin-left: 228px; max-width: 40em;">
<p>Esta es una combinación híbrida de los dos enfoques. Es como el método en serie para
  resolver una secuencia de colisiones individuales. Pero para cada colisión individual,
  considera todas las colisiones activas en ese cuerpo. Entonces obtenemos un buen resultado para el "uno
  golpea la caja de dos" con bloques cuadrados (vea la simulación a continuación).
</p>

<p>La primera colisión se resuelve simultáneamente para ambas colisiones en las esquinas
  entre los bloques izquierdo y central, por lo que obtiene un buen resultado simétrico: después de la primera
  colisión, el bloque de la izquierda está estacionario, y el bloque del medio se mueve hacia la derecha y
  comenzando a chocar con el bloque derecho (ver la imagen a la izquierda). A continuación, la segunda
  colisión se resuelve simultáneamente para ambas colisiones de esquina entre el medio y
  bloque derecho, con el resultado de que el bloque medio está estacionario y el bloque derecho se
  mueve.
</p>

<p>Intente seleccionar los otros métodos de colisión del menú para ver la diferencia; usted
  debe encontrar que sólo el método híbrido da los resultados "correctos".
</p>
</div>


<div id="container9" class="control_container" lang="es">
  <div id="div_graph9" >
  </div>
  <div id="div_time_graph9" >
  </div>
  <div id="sim_applet9" >
  </div>
  <div id="sim_controls9" class="control_group">
  </div>
  <div id="graph_controls9" class="control_group">
  </div>
  <div id="time_graph_controls9" class="control_group">
  </div>
  <p>
  <label id="label_show_sim9">
    <input type="checkbox" id="show_sim9">show sim
  </label>
  <label id="label_terminal9">
    <input type="checkbox" id="show_terminal9">terminal
  </label>
  <div id="div_terminal9">
    <textarea id="term_output9" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input9" size="80">
    </label>
  </div>
</div>

<p style="clear: both;">Este método híbrido decide qué colisiones considerar en cada
  paso ya que resuelve las colisiones en serie. El criterio es algo como esto: Tomar la
  colisión con la mayor velocidad, que está entre el cuerpo A y el cuerpo B; luego agrega
  cualquier otra colisión significativa que involucre cuerpos A o B. <i>Significativo</i> significa cualquier
  colisión con una gran velocidad, por lo que se ignoran los contactos en reposo.
</p>

<p>Este método híbrido también da un buen resultado simétrico en el escenario "uno colisiona con dos separados" que se muestra a continuación.
</p>


<div id="container10" class="control_container" lang="es">
  <div id="div_graph10" >
  </div>
  <div id="div_time_graph10" >
  </div>
  <div id="sim_applet10" >
  </div>
  <div id="sim_controls10" class="control_group">
  </div>
  <div id="graph_controls10" class="control_group">
  </div>
  <div id="time_graph_controls10" class="control_group">
  </div>
  <p>
  <label id="label_show_sim10">
    <input type="checkbox" id="show_sim10">show sim
  </label>
  <label id="label_terminal10">
    <input type="checkbox" id="show_terminal10">terminal
  </label>
  <div id="div_terminal10">
    <textarea id="term_output10" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input10" size="80">
    </label>
  </div>
</div>





<h2>Problemas con el método híbrido.</h2>

<p>El modelo híbrido no maneja correctamente los casos en los que hay múltiples colisiones
  con velocidades desiguales, porque se basa en el manejo simultáneo de colisiones
  para cada "evento de colisión" individual. A continuación se muestra un ejemplo donde hay 2
  colisiones simultáneas, pero a diferentes velocidades. Lo que debe pasar es que
  los discos izquierdo y derecho intercambian velocidades, y el disco central permanece estacionario.
</p>


<div id="container11" class="control_container" lang="es">
  <div id="div_graph11" >
  </div>
  <div id="div_time_graph11" >
  </div>
  <div id="sim_applet11" >
  </div>
  <div id="sim_controls11" class="control_group">
  </div>
  <div id="graph_controls11" class="control_group">
  </div>
  <div id="time_graph_controls11" class="control_group">
  </div>
  <p>
  <label id="label_show_sim11">
    <input type="checkbox" id="show_sim11">show sim
  </label>
  <label id="label_terminal11">
    <input type="checkbox" id="show_terminal11">terminal
  </label>
  <div id="div_terminal11">
    <textarea id="term_output11" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input11" size="80">
    </label>
  </div>
</div>


<p>El método en serie da el resultado correcto para este caso:
</p>


<div id="container12" class="control_container" lang="es">
  <div id="div_graph12" >
  </div>
  <div id="div_time_graph12" >
  </div>
  <div id="sim_applet12" >
  </div>
  <div id="sim_controls12" class="control_group">
  </div>
  <div id="graph_controls12" class="control_group">
  </div>
  <div id="time_graph_controls12" class="control_group">
  </div>
  <p>
  <label id="label_show_sim12">
    <input type="checkbox" id="show_sim12">show sim
  </label>
  <label id="label_terminal12">
    <input type="checkbox" id="show_terminal12">terminal
  </label>
  <div id="div_terminal12">
    <textarea id="term_output12" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input12" size="80">
    </label>
  </div>
</div>

<p>El resultado correcto debe ser el mismo que si no hubiera un disco central; el impacto
  las fuerzas deben transferirse a través del disco central (porque las masas son todas iguales y
  la elasticidad es 1). Aquí está la situación con solo 2 discos, y cualquiera de los solucionadores da
  el mismo resultado porque sólo se trata de una única colisión.
</p>


<div id="container13" class="control_container" lang="es">
  <div id="div_graph13" >
  </div>
  <div id="div_time_graph13" >
  </div>
  <div id="sim_applet13" >
  </div>
  <div id="sim_controls13" class="control_group">
  </div>
  <div id="graph_controls13" class="control_group">
  </div>
  <div id="time_graph_controls13" class="control_group">
  </div>
  <p>
  <label id="label_show_sim13">
    <input type="checkbox" id="show_sim13">show sim
  </label>
  <label id="label_terminal13">
    <input type="checkbox" id="show_terminal13">terminal
  </label>
  <div id="div_terminal13">
    <textarea id="term_output13" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input13" size="80">
    </label>
  </div>
</div>



<h2>Manejo de juntas y colisiones</h2>

<p>En el motor de física 2D de myphysicslab, las uniones se manejan de manera diferente a lo normal en
  colisiones y contactos entre cuerpos rígidos. Una junta es una conexión rígida permanente
  entre dos cuerpos, o entre un cuerpo y el fondo (masa infinita). Por ejemplo,
  en la construcción de un péndulo se hacen dos articulaciones en el punto de pivote; uno actúa
  horizontalmente y el otro actúa verticalmente.
</p>
<!--B>(PARA HACER: MÁS ACERCA DE LAS ARTICULACIONES EN OTRA PARTE DE LA PÁGINA DEL MOTOR DE FÍSICA 2D??)</B-->

<p>Aquí hay un ejemplo de escenario de colisión que involucra un par de cuerpos que están unidos y juntos.</p>


<div id="container19" class="control_container" lang="es">
  <div id="div_graph19" >
  </div>
  <div id="div_time_graph19" >
  </div>
  <div id="sim_applet19" >
  </div>
  <div id="sim_controls19" class="control_group">
  </div>
  <div id="graph_controls19" class="control_group">
  </div>
  <div id="time_graph_controls19" class="control_group">
  </div>
  <p>
  <label id="label_show_sim19">
    <input type="checkbox" id="show_sim19">show sim
  </label>
  <label id="label_terminal19">
    <input type="checkbox" id="show_terminal19">terminal
  </label>
  <div id="div_terminal19">
    <textarea id="term_output19" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input19" size="80">
    </label>
  </div>
</div>

<p>El método de manejo de colisiones predeterminado que se usa en las simulaciones de myphysicslab se llama
  "último paso agrupado en serie". Es un método de manejo de colisiones en serie, excepto que cuando
  las articulaciones están involucradas, hace un cálculo de colisión simultánea que involucra a todos los cuerpos
  conectados por juntas que están involucradas en cualquier lado de la colisión. Al igual que con el
  método híbrido descrito anteriormente, todavía hay una secuencia de colisiones, pero los pasos
  las articulaciones involucradas se calculan usando el método simultáneo.<p>

<h2>Colisiones basadas en muelles</h2>

<p>Un método diferente para manejar las colisiones consiste en colocar pequeños pero muy rígidos
  resortes en cada punto de colisión entre objetos. Los métodos simultáneo, en serie e híbrido
  considerados resuelven instantáneamente la colisión con un conjunto de
  impulsos. Por el contrario, con el manejo de colisiones basado en muelles, la simulación se continúa
  ejecutando <i>durante</i> la colisión. Debido a que los resortes involucrados son muy rígidos,
  los pasos de tiempo tomados durante la colisión deben ser muy pequeños.
</p>

<p>El método de muelles da el resultado correcto para la situación "uno colisiona con otro", como se ve
  en la simulación a continuación. (Esta simulación no es una simulación general de cuerpo rígido, sino
  muestra los resultados del uso de muelles en colisiones lineales simples).
</p>


<div id="container14" class="control_container" lang="es">
  <div id="div_graph14" >
  </div>
  <div id="div_time_graph14" >
  </div>
  <div id="sim_applet14" >
  </div>
  <div id="sim_controls14" class="control_group">
  </div>
  <div id="graph_controls14" class="control_group">
  </div>
  <div id="time_graph_controls14" class="control_group">
  </div>
  <p>
  <label id="label_show_sim14">
    <input type="checkbox" id="show_sim14">show sim
  </label>
  <label id="label_terminal14">
    <input type="checkbox" id="show_terminal14">terminal
  </label>
  <div id="div_terminal14">
    <textarea id="term_output14" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input14" size="80">
    </label>
  </div>
</div>

<p>Pero para la situación de "uno golpea dos", el método de muelles da un resultado incorrecto.
  El bloque izquierdo y medio se mueven después de la colisión, en lugar de permanecer
  inmóviles como deberían.
</p>


<div id="container15" class="control_container" lang="es">
  <div id="div_graph15" >
  </div>
  <div id="div_time_graph15" >
  </div>
  <div id="sim_applet15" >
  </div>
  <div id="sim_controls15" class="control_group">
  </div>
  <div id="graph_controls15" class="control_group">
  </div>
  <div id="time_graph_controls15" class="control_group">
  </div>
  <p>
  <label id="label_show_sim15">
    <input type="checkbox" id="show_sim15">show sim
  </label>
  <label id="label_terminal15">
    <input type="checkbox" id="show_terminal15">terminal
  </label>
  <div id="div_terminal15">
    <textarea id="term_output15" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input15" size="80">
    </label>
  </div>
</div>

<p>Sin embargo, si agrega un pequeño espacio entre los dos bloques, el comportamiento parece correcto.
</p>



<div id="container18" class="control_container" lang="es">
  <div id="div_graph18" >
  </div>
  <div id="div_time_graph18" >
  </div>
  <div id="sim_applet18" >
  </div>
  <div id="sim_controls18" class="control_group">
  </div>
  <div id="graph_controls18" class="control_group">
  </div>
  <div id="time_graph_controls18" class="control_group">
  </div>
  <p>
  <label id="label_show_sim18">
    <input type="checkbox" id="show_sim18">show sim
  </label>
  <label id="label_terminal18">
    <input type="checkbox" id="show_terminal18">terminal
  </label>
  <div id="div_terminal18">
    <textarea id="term_output18" cols=80 rows=20 wrap="soft"></textarea> <br>
    <label style="display:inline-block">command &gt;
      <input type="text" id="term_input18" size="80">
    </label>
  </div>
</div>




<h2>Conclusión: ¡Manejar múltiples colisiones es difícil!</h2>

<p>Entre los métodos de manejo de colisiones considerados aquí, ninguno da el resultado "correcto"
  para cada situación. Aunque se podría argumentar que nuestra expectativa de obtener
  los resultados perfectamente simétricos para colisiones múltiples no son realistas. Si usted acepta
  eso, entonces quizás el controlador de colisión en serie sea el mejor método.
</p>

<p>Un método de manejo de colisiones físicamente más preciso implicaría
  modelado de las propiedades de los objetos: cómo se deforman y rebotan. Usando tal
  modelo con una técnica de simulación avanzada como el análisis de elementos finitos puede dar resultados muy
  precisos, este tipo de técnicas se utilizan en la ciencia y la industria.
</p>

<p>Pero para las simulaciones simples de cuerpo rígido consideradas aquí, que queremos ejecutar
  rápidamente, de forma interactiva, en tiempo real, debemos aceptar que nuestro modelo simple no
  maneja siempre cada situación complicada que le lanzamos.
</p>

<p>El tiempo de ejecución del algoritmo es otra consideración para decidir qué método de manejo de colisiones
  utilizar; es decir, ¿cuánto tiempo de procesamiento informático se necesita para manejar
  la colisión? En este sentido, destaca el método simultáneo, porque predice los
  resultados de cada colisión usando la <a href="#equation1">ecuación (1)</a> y hace un solo
  cálculo para encontrar los impactos necesarios para dar ese resultado. El método en serie (y
  método híbrido) hacen varios cálculos, posiblemente docenas, para una colisión; por lo que se necesita
  más tiempo. El método de colisión de muelles necesita pasos de tiempo de escala muy fina durante la
  colisión porque los muelles involucrados son muy rígidos; esto toma más tiempo para realizar el cálculo.
</p>

<p>Hay una consideración más importante con el controlador de colisiones en serie: debido a
  todos los rebotes que ocurren cuando los objetos rebotan de un lado a otro, es posible
  obtener situaciones que nunca se resuelven. Donde la secuencia de colisiones continúa
  para siempre, lo que hace que el software se quede atascado en un bucle infinito. Una prueba puede ser
  agregando en el software rutinas para salir del proceso de manejo de colisiones si hay demasiadas colisiones
  ocurriendo; pero claro, entonces el resultado no será "correcto".
</p>

<p>Tabla de ventajas y desventajas de cada método.
</p>


<table border="1" width="100%">
  <tr>
    <th> </th>
    <th>simultáneo</th>
    <th>híbrido</th>
    <th>serie</th>
    <th>muelles</th>
  </tr>
  <tr>
    <th>velocidad</th>
    <td>rápido, solo un cálculo</td>
    <td>más tiempo para resolver la secuencia de colisiones</td>
    <td>más tiempo para resolver la secuencia de colisiones</td>
    <td>mucho más lento debido a los pasos de tiempo de escala fina durante las colisiones</td>
  </tr>
  <tr>
    <th>confiabilidad</th>
    <td>muy confiable</td>
    <td>posibilidad de secuencia de colisión infinita</td>
    <td>posibilidad de secuencia de colisión infinita</td>
    <td>posibilidad de que los muelles no resuelvan el estado de colisión</td>
  </tr>
  <tr>
    <th>validez en general</th>
    <td>la predicción de los resultados suele ser incorrecta</td>
    <td>el orden de resolución de la colisión afecta los resultados</td>
    <td>el orden de resolución de la colisión afecta los resultados</td>
    <td>la dinámica de los muelles no coincide muy bien con las colisiones reales</td>
  <tr>
    <th>validez para la cuna de Newton o discos "uno golpea dos"</th>
    <td>incorrecto</td>
    <td>correcto incluso con múltiples puntos de colisión (bloques)</td>
    <td>correcto si hay puntos únicos de colisión</td>
    <td>incorrecto</td>
  </tr>
  <tr>
    <th>validez para colisiones simétricas como "uno choca con dos separados"</th>
    <td>correcto</td>
    <td>correcto</td>
    <td>incorrecto</td>
    <td>correcto</td>
  </tr>
  <tr>
    <th>validez para colisiones asimétricas como "dos golpean a uno de forma asimétrica"</th>
     <td>incorrecto</td>
     <td>incorrecto</td>
     <td>correcto</td>
     <td>incorrecto</td>
  </tr>
</table>



<div id="footer2" >
  <div id="copyright">
    &copy; <a href="mailto:erikn@myPhysicsLab.com"
    title="send comments to Erik Neumann">
    Erik Neumann</a>,  2004-2016<br>
    <span id="revised_date">revisado Feb 6 2021</span>
  </div>
</div>
<script src="CollisionCombo-es.js"></script>

<script>

(function() {
  var apps = [];

  function addApp(app, num) {
    var elem_id = "sim_applet"+num;
    var elem = document.getElementById(elem_id);
    if (elem === undefined) {
      throw new Error('no such element id: '+elem_id);
    }
    apps.push({
      app: app,
      elem: elem,
      visible: false
      });
    app.eval('SIM_CANVAS.BACKGROUND="white"',/*output=*/false)
  }

  function checkVisible(app_info) {
    // the documentElement stuff is for IE (Internet Explorer).
    var window_offset = (typeof(window.pageYOffset)== 'number') ? window.pageYOffset :
      document.documentElement.scrollTop;
    var window_height = (typeof(window.innerHeight)== 'number') ? window.innerHeight :
      document.documentElement.clientHeight;
    var elem = app_info.elem;
    var app = app_info.app;
    // is the element fully visible?
    if (elem.offsetTop >= window_offset &&
        elem.offsetTop + elem.offsetHeight <= window_offset + window_height) {
      if (!app_info.visible) {
        //console.log( "elem "+elem.id+" is visible");
        app.start();
        app.eval('FIRING=true;RUNNING=true;');
        app_info.visible = true;
      }
    } else {
      if (app_info.visible) {
        //console.log( "elem "+elem.id+" is not visible");
        app.eval('FIRING=false;');
        app_info.visible = false;
      }
    }
  }

  function appletControl() {
    for (var i=0; i<apps.length; i++) {
      checkVisible(apps[i]);
    }
  }

  function deactivateAll() {
    for (var i=0; i<apps.length; i++) {
      apps[i].app.eval('FIRING=false;');
      apps[i].visible = false;
    }
  }

  window.addEventListener('scroll', appletControl);
  window.addEventListener('resize', appletControl);
  window.addEventListener('focus', appletControl);
  window.addEventListener('blur', deactivateAll);

  var elem_ids1 = {
      tab_list: 'header_bar',
      container: 'container1',
      term_output: 'term_output1',
      term_input: 'term_input1',
      sim_applet: 'sim_applet1',
      div_graph: 'div_graph1',
      graph_controls: 'graph_controls1',
      sim_controls: 'sim_controls1',
      div_terminal: 'div_terminal1',
      div_time_graph: 'div_time_graph1',
      time_graph_controls: 'time_graph_controls1',
      div_multi_graph: 'div_multi_graph1',
      multi_graph_controls: 'multi_graph_controls1',
      label_terminal: 'label_terminal1',
      show_terminal: 'show_terminal1',
      show_sim: 'show_sim1',
      images_dir: '../common'
    };
  app1 = makeMultipleCollisionApp(elem_ids1);
  app1.defineNames('app1');
  app1.eval('FORMATION=ONE_HITS_TWO;SHAPE=CIRCLE;COLLISION_METHOD="simultaneous";');
  addApp(app1, 1);

  var elem_ids2 = {
      tab_list: 'header_bar',
      container: 'container2',
      term_output: 'term_output2',
      term_input: 'term_input2',
      sim_applet: 'sim_applet2',
      div_graph: 'div_graph2',
      graph_controls: 'graph_controls2',
      sim_controls: 'sim_controls2',
      div_terminal: 'div_terminal2',
      div_time_graph: 'div_time_graph2',
      time_graph_controls: 'time_graph_controls2',
      div_multi_graph: 'div_multi_graph2',
      multi_graph_controls: 'multi_graph_controls2',
      label_terminal: 'label_terminal2',
      show_terminal: 'show_terminal2',
      show_sim: 'show_sim2',
      images_dir: '../common'
    };
  app2 = makeMultipleCollisionApp(elem_ids2);
  app2.defineNames('app2');
  app2.eval('FORMATION=ONE_HITS_ONE;SHAPE=CIRCLE;COLLISION_METHOD="simultaneous";');
  addApp(app2, 2);

  var elem_ids3 = {
      tab_list: 'header_bar',
      container: 'container3',
      term_output: 'term_output3',
      term_input: 'term_input3',
      sim_applet: 'sim_applet3',
      div_graph: 'div_graph3',
      graph_controls: 'graph_controls3',
      sim_controls: 'sim_controls3',
      div_terminal: 'div_terminal3',
      div_time_graph: 'div_time_graph3',
      time_graph_controls: 'time_graph_controls3',
      div_multi_graph: 'div_multi_graph3',
      multi_graph_controls: 'multi_graph_controls3',
      label_terminal: 'label_terminal3',
      show_terminal: 'show_terminal3',
      show_sim: 'show_sim3',
      images_dir: '../common'
    };
  app3 = makeMultipleCollisionApp(elem_ids3);
  app3.defineNames('app3');
  app3.eval('FORMATION=ONE_HITS_TWO;SHAPE=CIRCLE;COLLISION_METHOD="simultaneous"; OFFSET=0.1;');
  addApp(app3, 3);

  var elem_ids4 = {
      tab_list: 'header_bar',
      container: 'container4',
      term_output: 'term_output4',
      term_input: 'term_input4',
      sim_applet: 'sim_applet4',
      div_graph: 'div_graph4',
      graph_controls: 'graph_controls4',
      sim_controls: 'sim_controls4',
      div_terminal: 'div_terminal4',
      div_time_graph: 'div_time_graph4',
      time_graph_controls: 'time_graph_controls4',
      div_multi_graph: 'div_multi_graph4',
      multi_graph_controls: 'multi_graph_controls4',
      label_terminal: 'label_terminal4',
      show_terminal: 'show_terminal4',
      show_sim: 'show_sim4',
      images_dir: '../common'
    };
  app4 = makeMultipleCollisionApp(elem_ids4);
  app4.defineNames('app4');
  app4.eval('FORMATION=ONE_HITS_TWO;SHAPE=CIRCLE;COLLISION_METHOD="serial separate";');
  addApp(app4, 4);

  var elem_ids5 = {
      tab_list: 'header_bar',
      container: 'container5',
      term_output: 'term_output5',
      term_input: 'term_input5',
      sim_applet: 'sim_applet5',
      div_graph: 'div_graph5',
      graph_controls: 'graph_controls5',
      sim_controls: 'sim_controls5',
      div_terminal: 'div_terminal5',
      div_time_graph: 'div_time_graph5',
      time_graph_controls: 'time_graph_controls5',
      div_multi_graph: 'div_multi_graph5',
      multi_graph_controls: 'multi_graph_controls5',
      label_terminal: 'label_terminal5',
      show_terminal: 'show_terminal5',
      show_sim: 'show_sim5',
      images_dir: '../common'
    };
  app5 = makeMultipleCollisionApp(elem_ids5);
  app5.defineNames('app5');
  app5.eval('FORMATION=ONE_HITS_WALL;SHAPE=SQUARE;COLLISION_METHOD="serial grouped lastpass";');
  addApp(app5, 5);

  var elem_ids6 = {
      tab_list: 'header_bar',
      container: 'container6',
      term_output: 'term_output6',
      term_input: 'term_input6',
      sim_applet: 'sim_applet6',
      div_graph: 'div_graph6',
      graph_controls: 'graph_controls6',
      sim_controls: 'sim_controls6',
      div_terminal: 'div_terminal6',
      div_time_graph: 'div_time_graph6',
      time_graph_controls: 'time_graph_controls6',
      div_multi_graph: 'div_multi_graph6',
      multi_graph_controls: 'multi_graph_controls6',
      label_terminal: 'label_terminal6',
      show_terminal: 'show_terminal6',
      show_sim: 'show_sim6',
      images_dir: '../common'
    };
  app6 = makeMultipleCollisionApp(elem_ids6);
  app6.defineNames('app6');
  app6.eval('FORMATION=ONE_HITS_WALL;SHAPE=SQUARE;COLLISION_METHOD="simultaneous";');
  addApp(app6, 6);

  var elem_ids7 = {
      tab_list: 'header_bar',
      container: 'container7',
      term_output: 'term_output7',
      term_input: 'term_input7',
      sim_applet: 'sim_applet7',
      div_graph: 'div_graph7',
      graph_controls: 'graph_controls7',
      sim_controls: 'sim_controls7',
      div_terminal: 'div_terminal7',
      div_time_graph: 'div_time_graph7',
      time_graph_controls: 'time_graph_controls7',
      div_multi_graph: 'div_multi_graph7',
      multi_graph_controls: 'multi_graph_controls7',
      label_terminal: 'label_terminal7',
      show_terminal: 'show_terminal7',
      show_sim: 'show_sim7',
      images_dir: '../common'
    };
  app7 = makeMultipleCollisionApp(elem_ids7);
  app7.defineNames('app7');
  app7.eval('FORMATION=ONE_HITS_WALL;SHAPE=SQUARE;COLLISION_METHOD="simultaneous"; ANGLE=0.01;');
  addApp(app7, 7);

  var elem_ids8 = {
      tab_list: 'header_bar',
      container: 'container8',
      term_output: 'term_output8',
      term_input: 'term_input8',
      sim_applet: 'sim_applet8',
      div_graph: 'div_graph8',
      graph_controls: 'graph_controls8',
      sim_controls: 'sim_controls8',
      div_terminal: 'div_terminal8',
      div_time_graph: 'div_time_graph8',
      time_graph_controls: 'time_graph_controls8',
      div_multi_graph: 'div_multi_graph8',
      multi_graph_controls: 'multi_graph_controls8',
      label_terminal: 'label_terminal8',
      show_terminal: 'show_terminal8',
      show_sim: 'show_sim8',
      images_dir: '../common'
    };
  app8 = makeMultipleCollisionApp(elem_ids8);
  app8.defineNames('app8');
  app8.eval('FORMATION=ONE_HITS_TWO_SEPARATE;SHAPE=CIRCLE;COLLISION_METHOD="serial grouped lastpass";');
  addApp(app8, 8);

  var elem_ids9 = {
      tab_list: 'header_bar',
      container: 'container9',
      term_output: 'term_output9',
      term_input: 'term_input9',
      sim_applet: 'sim_applet9',
      div_graph: 'div_graph9',
      graph_controls: 'graph_controls9',
      sim_controls: 'sim_controls9',
      div_terminal: 'div_terminal9',
      div_time_graph: 'div_time_graph9',
      time_graph_controls: 'time_graph_controls9',
      div_multi_graph: 'div_multi_graph9',
      multi_graph_controls: 'multi_graph_controls9',
      label_terminal: 'label_terminal9',
      show_terminal: 'show_terminal9',
      show_sim: 'show_sim9',
      images_dir: '../common'
    };
  app9 = makeMultipleCollisionApp(elem_ids9);
  app9.defineNames('app9');
  app9.eval('FORMATION=ONE_HITS_TWO;SHAPE=SQUARE;COLLISION_METHOD="hybrid";');
  addApp(app9, 9);

  var elem_ids10 = {
      tab_list: 'header_bar',
      container: 'container10',
      term_output: 'term_output10',
      term_input: 'term_input10',
      sim_applet: 'sim_applet10',
      div_graph: 'div_graph10',
      graph_controls: 'graph_controls10',
      sim_controls: 'sim_controls10',
      div_terminal: 'div_terminal10',
      div_time_graph: 'div_time_graph10',
      time_graph_controls: 'time_graph_controls10',
      div_multi_graph: 'div_multi_graph10',
      multi_graph_controls: 'multi_graph_controls10',
      label_terminal: 'label_terminal10',
      show_terminal: 'show_terminal10',
      show_sim: 'show_sim10',
      images_dir: '../common'
    };
  app10 = makeMultipleCollisionApp(elem_ids10);
  app10.defineNames('app10');
  app10.eval('FORMATION=ONE_HITS_TWO_SEPARATE;SHAPE=CIRCLE;COLLISION_METHOD="hybrid";');
  addApp(app10, 10);

  var elem_ids11 = {
      tab_list: 'header_bar',
      container: 'container11',
      term_output: 'term_output11',
      term_input: 'term_input11',
      sim_applet: 'sim_applet11',
      div_graph: 'div_graph11',
      graph_controls: 'graph_controls11',
      sim_controls: 'sim_controls11',
      div_terminal: 'div_terminal11',
      div_time_graph: 'div_time_graph11',
      time_graph_controls: 'time_graph_controls11',
      div_multi_graph: 'div_multi_graph11',
      multi_graph_controls: 'multi_graph_controls11',
      label_terminal: 'label_terminal11',
      show_terminal: 'show_terminal11',
      show_sim: 'show_sim11',
      images_dir: '../common'
    };
  app11 = makeMultipleCollisionApp(elem_ids11);
  app11.defineNames('app11');
  app11.eval('FORMATION=TWO_HIT_ONE_ASYMMETRIC;SHAPE=CIRCLE; COLLISION_METHOD="hybrid";');
  addApp(app11, 11);

  var elem_ids12 = {
      tab_list: 'header_bar',
      container: 'container12',
      term_output: 'term_output12',
      term_input: 'term_input12',
      sim_applet: 'sim_applet12',
      div_graph: 'div_graph12',
      graph_controls: 'graph_controls12',
      sim_controls: 'sim_controls12',
      div_terminal: 'div_terminal12',
      div_time_graph: 'div_time_graph12',
      time_graph_controls: 'time_graph_controls12',
      div_multi_graph: 'div_multi_graph12',
      multi_graph_controls: 'multi_graph_controls12',
      label_terminal: 'label_terminal12',
      show_terminal: 'show_terminal12',
      show_sim: 'show_sim12',
      images_dir: '../common'
    };
  app12 = makeMultipleCollisionApp(elem_ids12);
  app12.defineNames('app12');
  app12.eval('FORMATION=TWO_HIT_ONE_ASYMMETRIC;SHAPE=CIRCLE;COLLISION_METHOD="serial grouped lastpass";');
  addApp(app12, 12);

  var elem_ids13 = {
      tab_list: 'header_bar',
      container: 'container13',
      term_output: 'term_output13',
      term_input: 'term_input13',
      sim_applet: 'sim_applet13',
      div_graph: 'div_graph13',
      graph_controls: 'graph_controls13',
      sim_controls: 'sim_controls13',
      div_terminal: 'div_terminal13',
      div_time_graph: 'div_time_graph13',
      time_graph_controls: 'time_graph_controls13',
      div_multi_graph: 'div_multi_graph13',
      multi_graph_controls: 'multi_graph_controls13',
      label_terminal: 'label_terminal13',
      show_terminal: 'show_terminal13',
      show_sim: 'show_sim13',
      images_dir: '../common'
    };
  app13 = makeMultipleCollisionApp(elem_ids13);
  app13.defineNames('app13');
  app13.eval('FORMATION=ONE_HITS_ONE_ASYMMETRIC;SHAPE=CIRCLE; COLLISION_METHOD="hybrid";');
  addApp(app13, 13);

  var elem_ids14 = {
      tab_list: 'header_bar',
      container: 'container14',
      term_output: 'term_output14',
      term_input: 'term_input14',
      sim_applet: 'sim_applet14',
      div_graph: 'div_graph14',
      graph_controls: 'graph_controls14',
      sim_controls: 'sim_controls14',
      div_terminal: 'div_terminal14',
      div_time_graph: 'div_time_graph14',
      time_graph_controls: 'time_graph_controls14',
      div_multi_graph: 'div_multi_graph14',
      multi_graph_controls: 'multi_graph_controls14',
      label_terminal: 'label_terminal14',
      show_terminal: 'show_terminal14',
      show_sim: 'show_sim14',
      images_dir: '../common'
    };
  app14 = makeCollideSpringApp(elem_ids14);
  app14.defineNames('app14');
  app14.eval('NUMBER_BLOCKS=2;STARTING_GAP=0;');
  addApp(app14, 14);

  var elem_ids15 = {
      tab_list: 'header_bar',
      container: 'container15',
      term_output: 'term_output15',
      term_input: 'term_input15',
      sim_applet: 'sim_applet15',
      div_graph: 'div_graph15',
      graph_controls: 'graph_controls15',
      sim_controls: 'sim_controls15',
      div_terminal: 'div_terminal15',
      div_time_graph: 'div_time_graph15',
      time_graph_controls: 'time_graph_controls15',
      div_multi_graph: 'div_multi_graph15',
      multi_graph_controls: 'multi_graph_controls15',
      label_terminal: 'label_terminal15',
      show_terminal: 'show_terminal15',
      show_sim: 'show_sim15',
      images_dir: '../common'
    };
  app15 = makeCollideSpringApp(elem_ids15);
  app15.defineNames('app15');
  app15.eval('NUMBER_BLOCKS=3;STARTING_GAP=0;');
  addApp(app15, 15);

  var elem_ids16 = {
      tab_list: 'header_bar',
      container: 'container16',
      term_output: 'term_output16',
      term_input: 'term_input16',
      sim_applet: 'sim_applet16',
      div_graph: 'div_graph16',
      graph_controls: 'graph_controls16',
      sim_controls: 'sim_controls16',
      div_terminal: 'div_terminal16',
      div_time_graph: 'div_time_graph16',
      time_graph_controls: 'time_graph_controls16',
      div_multi_graph: 'div_multi_graph16',
      multi_graph_controls: 'multi_graph_controls16',
      label_terminal: 'label_terminal16',
      show_terminal: 'show_terminal16',
      show_sim: 'show_sim16',
      images_dir: '../common'
    };
  app16 = makeMultipleCollisionApp(elem_ids16);
  app16.defineNames('app16');
  app16.eval('FORMATION=ONE_HITS_TWO_IN_BOX;COLLISION_METHOD="serial grouped lastpass";');
  addApp(app16, 16);

  var elem_ids17 = {
      tab_list: 'header_bar',
      container: 'container17',
      term_output: 'term_output17',
      term_input: 'term_input17',
      sim_applet: 'sim_applet17',
      div_graph: 'div_graph17',
      graph_controls: 'graph_controls17',
      sim_controls: 'sim_controls17',
      div_terminal: 'div_terminal17',
      div_time_graph: 'div_time_graph17',
      time_graph_controls: 'time_graph_controls17',
      div_multi_graph: 'div_multi_graph17',
      multi_graph_controls: 'multi_graph_controls17',
      label_terminal: 'label_terminal17',
      show_terminal: 'show_terminal17',
      show_sim: 'show_sim17',
      images_dir: '../common'
    };
  app17 = makeMultipleCollisionApp(elem_ids17);
  app17.defineNames('app17');
  app17.eval('FORMATION=ONE_HITS_ONE_ON_WALL;COLLISION_METHOD="serial grouped lastpass";ELASTICITY=0;SHAPE=CIRCLE');
  addApp(app17, 17);

  var elem_ids18 = {
      tab_list: 'header_bar',
      container: 'container18',
      term_output: 'term_output18',
      term_input: 'term_input18',
      sim_applet: 'sim_applet18',
      div_graph: 'div_graph18',
      graph_controls: 'graph_controls18',
      sim_controls: 'sim_controls18',
      div_terminal: 'div_terminal18',
      div_time_graph: 'div_time_graph18',
      time_graph_controls: 'time_graph_controls18',
      div_multi_graph: 'div_multi_graph18',
      multi_graph_controls: 'multi_graph_controls18',
      label_terminal: 'label_terminal18',
      show_terminal: 'show_terminal18',
      show_sim: 'show_sim18',
      images_dir: '../common'
    };
  app18 = makeCollideSpringApp(elem_ids18);
  app18.defineNames('app18');
  app18.eval('NUMBER_BLOCKS=3;STARTING_GAP=0.1;');
  addApp(app18, 18);

  var elem_ids19 = {
      tab_list: 'header_bar',
      container: 'container19',
      term_output: 'term_output19',
      term_input: 'term_input19',
      sim_applet: 'sim_applet19',
      div_graph: 'div_graph19',
      graph_controls: 'graph_controls19',
      sim_controls: 'sim_controls19',
      div_terminal: 'div_terminal19',
      div_time_graph: 'div_time_graph19',
      time_graph_controls: 'time_graph_controls19',
      div_multi_graph: 'div_multi_graph19',
      multi_graph_controls: 'multi_graph_controls19',
      label_terminal: 'label_terminal19',
      show_terminal: 'show_terminal19',
      show_sim: 'show_sim19',
      images_dir: '../common'
    };
  app19 = makeMultipleCollisionApp(elem_ids19);
  app19.defineNames('app19');
  app19.eval('FORMATION=ONE_HITS_CHAIN_PLUS_ONE;COLLISION_METHOD="serial grouped lastpass";ELASTICITY=1;SHAPE=CIRCLE');
  addApp(app19, 19);

})();
</script>

<script>
  document.getElementsByTagName("html")[0].style.visibility = "visible";
</script>
</body>
</html>
